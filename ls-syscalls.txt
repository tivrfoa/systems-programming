## brk

BRK(2)                                                       Linux Programmer's Manual                                                      BRK(2)

NAME
       brk, sbrk - change data segment size

SYNOPSIS
       #include <unistd.h>

       int brk(void *addr);

       void *sbrk(intptr_t increment);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       brk(), sbrk():
           Since glibc 2.19:
               _DEFAULT_SOURCE ||
                   (_XOPEN_SOURCE >= 500) &&
                   ! (_POSIX_C_SOURCE >= 200112L)
           From glibc 2.12 to 2.19:
               _BSD_SOURCE || _SVID_SOURCE ||
                   (_XOPEN_SOURCE >= 500) &&
                   ! (_POSIX_C_SOURCE >= 200112L)
           Before glibc 2.12:
               _BSD_SOURCE || _SVID_SOURCE || _XOPEN_SOURCE >= 500

DESCRIPTION
       brk()  and sbrk() change the location of the program break, which defines the end of the process's data segment (i.e., the program break is
       the first location after the end of the uninitialized data segment).  Increasing the program break has the effect of allocating  memory  to
       the process; decreasing the break deallocates memory.

       brk() sets the end of the data segment to the value specified by addr, when that value is reasonable, the system has enough memory, and the
       process does not exceed its maximum data size (see setrlimit(2)).

       sbrk() increments the program's data space by increment bytes.  Calling sbrk() with an increment of 0 can be used to find the current loca‐
       tion of the program break.

RETURN VALUE
       On success, brk() returns zero.  On error, -1 is returned, and errno is set to ENOMEM.

       On success, sbrk() returns the previous program break.  (If the break was increased, then this value is a pointer to the start of the newly
       allocated memory).  On error, (void *) -1 is returned, and errno is set to ENOMEM.

CONFORMING TO
       4.3BSD; SUSv1, marked LEGACY in SUSv2, removed in POSIX.1-2001.

NOTES
       Avoid using brk() and sbrk(): the malloc(3) memory allocation package is the portable and comfortable way of allocating memory.

       Various systems use various types for the argument of sbrk().  Common are int, ssize_t, ptrdiff_t, intptr_t.

   C library/kernel differences
       The return value described above for brk() is the behavior provided by the glibc wrapper function for the Linux  brk()  system  call.   (On
       most  other  implementations, the return value from brk() is the same; this return value was also specified in SUSv2.)  However, the actual
       Linux system call returns the new program break on success.  On failure, the system call returns the  current  break.   The  glibc  wrapper
       function does some work (i.e., checks whether the new break is less than addr) to provide the 0 and -1 return values described above.

       On  Linux,  sbrk()  is implemented as a library function that uses the brk() system call, and does some internal bookkeeping so that it can
       return the old break value.

SEE ALSO
       execve(2), getrlimit(2), end(3), malloc(3)

COLOPHON
       This page is part of release 5.10 of the Linux man-pages project.  A description of the project, information about reporting bugs, and  the
       latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                               2016-03-15                                                              BRK(2)

## arch_prctl

ARCH_PRCTL(2)                                                Linux Programmer's Manual                                               ARCH_PRCTL(2)

NAME
       arch_prctl - set architecture-specific thread state

SYNOPSIS
       #include <asm/prctl.h>
       #include <sys/prctl.h>

       int arch_prctl(int code, unsigned long addr);
       int arch_prctl(int code, unsigned long *addr);

DESCRIPTION
       arch_prctl() sets architecture-specific process or thread state.  code selects a subfunction and passes argument addr to it; addr is inter‐
       preted as either an unsigned long for the "set" operations, or as an unsigned long *, for the "get" operations.

       Subfunctions for both x86 and x86-64 are:

       ARCH_SET_CPUID (since Linux 4.12)
              Enable (addr != 0) or disable (addr == 0) the cpuid instruction for the calling thread.  The instruction is enabled by default.   If
              disabled,  any  execution  of a cpuid instruction will instead generate a SIGSEGV signal.  This feature can be used to emulate cpuid
              results that differ from what the underlying hardware would have produced (e.g., in a paravirtualization setting).

              The ARCH_SET_CPUID setting is preserved across fork(2) and clone(2) but reset to the default (i.e., cpuid enabled) on execve(2).

       ARCH_GET_CPUID (since Linux 4.12)
              Return the setting of the flag manipulated by ARCH_SET_CPUID as the result of the system call (1 for enabled, 0 for disabled).  addr
              is ignored.

       Subfunctions for x86-64 only are:

       ARCH_SET_FS
              Set the 64-bit base for the FS register to addr.

       ARCH_GET_FS
              Return the 64-bit base value for the FS register of the calling thread in the unsigned long pointed to by addr.

       ARCH_SET_GS
              Set the 64-bit base for the GS register to addr.

       ARCH_GET_GS
              Return the 64-bit base value for the GS register of the calling thread in the unsigned long pointed to by addr.

RETURN VALUE
       On success, arch_prctl() returns 0; on error, -1 is returned, and errno is set to indicate the error.

ERRORS
       EFAULT addr points to an unmapped address or is outside the process address space.

       EINVAL code is not a valid subcommand.

       EPERM  addr is outside the process address space.

       ENODEV ARCH_SET_CPUID was requested, but the underlying hardware does not support CPUID faulting.

CONFORMING TO
       arch_prctl() is a Linux/x86-64 extension and should not be used in programs intended to be portable.

NOTES
       arch_prctl() is supported only on Linux/x86-64 for 64-bit programs currently.

       The 64-bit base changes when a new 32-bit segment selector is loaded.

       ARCH_SET_GS is disabled in some kernels.

       Context switches for 64-bit segment bases are rather expensive.  As an optimization, if a 32-bit TLS base address is used, arch_prctl() may
       use a real TLS entry as if set_thread_area(2) had been called, instead of manipulating the segment base register directly.  Memory  in  the
       first 2 GB of address space can be allocated by using mmap(2) with the MAP_32BIT flag.

       Because  of  the  aforementioned optimization, using arch_prctl() and set_thread_area(2) in the same thread is dangerous, as they may over‐
       write each other's TLS entries.

       As of version 2.7, glibc provides no prototype for arch_prctl().  You have to declare it yourself for now.  This may  be  fixed  in  future
       glibc versions.

       FS may be already used by the threading library.  Programs that use ARCH_SET_FS directly are very likely to crash.

SEE ALSO
       mmap(2), modify_ldt(2), prctl(2), set_thread_area(2)

       AMD X86-64 Programmer's manual

COLOPHON
       This  page is part of release 5.10 of the Linux man-pages project.  A description of the project, information about reporting bugs, and the
       latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                               2020-04-11                                                       ARCH_PRCTL(2)

## openat

OPEN(2)                                                      Linux Programmer's Manual                                                     OPEN(2)

NAME
       open, openat, creat - open and possibly create a file

SYNOPSIS
       #include <sys/types.h>
       #include <sys/stat.h>
       #include <fcntl.h>

       int open(const char *pathname, int flags);
       int open(const char *pathname, int flags, mode_t mode);

       int creat(const char *pathname, mode_t mode);

       int openat(int dirfd, const char *pathname, int flags);
       int openat(int dirfd, const char *pathname, int flags, mode_t mode);

       /* Documented separately, in openat2(2): */
       int openat2(int dirfd, const char *pathname,
                   const struct open_how *how, size_t size);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       openat():
           Since glibc 2.10:
               _POSIX_C_SOURCE >= 200809L
           Before glibc 2.10:
               _ATFILE_SOURCE

DESCRIPTION
       The open() system call opens the file specified by pathname.  If the specified file does not exist, it may optionally (if O_CREAT is speci‐
       fied in flags) be created by open().

       The return value of open() is a file descriptor, a small, nonnegative integer that is used in subsequent system calls  (read(2),  write(2),
       lseek(2),  fcntl(2),  etc.)  to refer to the open file.  The file descriptor returned by a successful call will be the lowest-numbered file
       descriptor not currently open for the process.

       By default, the new file descriptor is set to remain open across an execve(2) (i.e., the FD_CLOEXEC file descriptor flag described  in  fc‐
       ntl(2)  is initially disabled); the O_CLOEXEC flag, described below, can be used to change this default.  The file offset is set to the be‐
       ginning of the file (see lseek(2)).

       A call to open() creates a new open file description, an entry in the system-wide table of open files.  The open file  description  records
       the file offset and the file status flags (see below).  A file descriptor is a reference to an open file description; this reference is un‐
       affected if pathname is subsequently removed or modified to refer to a different file.  For further details on open file descriptions,  see
       NOTES.

       The  argument  flags  must  include one of the following access modes: O_RDONLY, O_WRONLY, or O_RDWR.  These request opening the file read-
       only, write-only, or read/write, respectively.

       In addition, zero or more file creation flags and file status flags can be bitwise-or'd in flags.  The file creation flags  are  O_CLOEXEC,
       O_CREAT,  O_DIRECTORY,  O_EXCL,  O_NOCTTY, O_NOFOLLOW, O_TMPFILE, and O_TRUNC.  The file status flags are all of the remaining flags listed
       below.  The distinction between these two groups of flags is that the file creation flags affect the semantics of the  open  operation  it‐
       self,  while  the file status flags affect the semantics of subsequent I/O operations.  The file status flags can be retrieved and (in some
       cases) modified; see fcntl(2) for details.

       The full list of file creation flags and file status flags is as follows:

       O_APPEND
              The file is opened in append mode.  Before each write(2), the file offset is positioned at the end of the file, as if with lseek(2).
              The modification of the file offset and the write operation are performed as a single atomic step.

              O_APPEND  may  lead  to corrupted files on NFS filesystems if more than one process appends data to a file at once.  This is because
              NFS does not support appending to a file, so the client kernel has to simulate it, which can't be done without a race condition.

       O_ASYNC
              Enable signal-driven I/O: generate a signal (SIGIO by default, but this can be changed via fcntl(2)) when input  or  output  becomes
              possible  on  this  file  descriptor.  This feature is available only for terminals, pseudoterminals, sockets, and (since Linux 2.6)
              pipes and FIFOs.  See fcntl(2) for further details.  See also BUGS, below.

       O_CLOEXEC (since Linux 2.6.23)
              Enable the close-on-exec flag for the new file descriptor.  Specifying this flag permits a  program  to  avoid  additional  fcntl(2)
              F_SETFD operations to set the FD_CLOEXEC flag.

              Note  that  the use of this flag is essential in some multithreaded programs, because using a separate fcntl(2) F_SETFD operation to
              set the FD_CLOEXEC flag does not suffice to avoid race conditions where one thread opens a file descriptor and attempts to  set  its
              close-on-exec  flag using fcntl(2) at the same time as another thread does a fork(2) plus execve(2).  Depending on the order of exe‐
              cution, the race may lead to the file descriptor returned by open() being unintentionally leaked to  the  program  executed  by  the
              child  process  created  by fork(2).  (This kind of race is in principle possible for any system call that creates a file descriptor
              whose close-on-exec flag should be set, and various other Linux system calls provide an equivalent of the  O_CLOEXEC  flag  to  deal
              with this problem.)

       O_CREAT
              If pathname does not exist, create it as a regular file.

              The owner (user ID) of the new file is set to the effective user ID of the process.

              The group ownership (group ID) of the new file is set either to the effective group ID of the process (System V semantics) or to the
              group ID of the parent directory (BSD semantics).  On Linux, the behavior depends on whether the set-group-ID mode bit is set on the
              parent  directory: if that bit is set, then BSD semantics apply; otherwise, System V semantics apply.  For some filesystems, the be‐
              havior also depends on the bsdgroups and sysvgroups mount options described in mount(8).

              The mode argument specifies the file mode bits to be applied when a new file is created.  If neither O_CREAT nor O_TMPFILE is speci‐
              fied  in  flags,  then  mode  is ignored (and can thus be specified as 0, or simply omitted).  The mode argument must be supplied if
              O_CREAT or O_TMPFILE is specified in flags; if it is not supplied, some arbitrary bytes from the stack will be applied as  the  file
              mode.

              The  effective  mode  is  modified by the process's umask in the usual way: in the absence of a default ACL, the mode of the created
              file is (mode & ~umask).

              Note that mode applies only to future accesses of the newly created file; the open() call that creates a read-only file may well re‐
              turn a read/write file descriptor.

              The following symbolic constants are provided for mode:

              S_IRWXU  00700 user (file owner) has read, write, and execute permission

              S_IRUSR  00400 user has read permission

              S_IWUSR  00200 user has write permission

              S_IXUSR  00100 user has execute permission

              S_IRWXG  00070 group has read, write, and execute permission

              S_IRGRP  00040 group has read permission

              S_IWGRP  00020 group has write permission

              S_IXGRP  00010 group has execute permission

              S_IRWXO  00007 others have read, write, and execute permission

              S_IROTH  00004 others have read permission

              S_IWOTH  00002 others have write permission

              S_IXOTH  00001 others have execute permission

              According  to  POSIX,  the  effect when other bits are set in mode is unspecified.  On Linux, the following bits are also honored in
              mode:

              S_ISUID  0004000 set-user-ID bit

              S_ISGID  0002000 set-group-ID bit (see inode(7)).

              S_ISVTX  0001000 sticky bit (see inode(7)).

       O_DIRECT (since Linux 2.4.10)
              Try to minimize cache effects of the I/O to and from this file.  In general this will degrade performance, but it is useful in  spe‐
              cial  situations,  such as when applications do their own caching.  File I/O is done directly to/from user-space buffers.  The O_DI‐
              RECT flag on its own makes an effort to transfer data synchronously, but does not give the guarantees of the O_SYNC flag  that  data
              and necessary metadata are transferred.  To guarantee synchronous I/O, O_SYNC must be used in addition to O_DIRECT.  See NOTES below
              for further discussion.

              A semantically similar (but deprecated) interface for block devices is described in raw(8).

       O_DIRECTORY
              If pathname is not a directory, cause the open to fail.  This flag was added in kernel version 2.1.126, to  avoid  denial-of-service
              problems if opendir(3) is called on a FIFO or tape device.

       O_DSYNC
              Write operations on the file will complete according to the requirements of synchronized I/O data integrity completion.

              By  the  time  write(2)  (and  similar) return, the output data has been transferred to the underlying hardware, along with any file
              metadata that would be required to retrieve that data (i.e., as though each write(2) was followed by a call to  fdatasync(2)).   See
              NOTES below.

       O_EXCL Ensure  that  this  call  creates the file: if this flag is specified in conjunction with O_CREAT, and pathname already exists, then
              open() fails with the error EEXIST.

              When these two flags are specified, symbolic links are not followed: if pathname is a symbolic link, then open() fails regardless of
              where the symbolic link points.

              In  general,  the  behavior  of  O_EXCL is undefined if it is used without O_CREAT.  There is one exception: on Linux 2.6 and later,
              O_EXCL can be used without O_CREAT if pathname refers to a block device.  If the block  device  is  in  use  by  the  system  (e.g.,
              mounted), open() fails with the error EBUSY.

              On  NFS, O_EXCL is supported only when using NFSv3 or later on kernel 2.6 or later.  In NFS environments where O_EXCL support is not
              provided, programs that rely on it for performing locking tasks will contain a race condition.  Portable programs that want to  per‐
              form  atomic  file  locking  using a lockfile, and need to avoid reliance on NFS support for O_EXCL, can create a unique file on the
              same filesystem (e.g., incorporating hostname and PID), and use link(2) to make a link to the lockfile.  If link(2) returns  0,  the
              lock is successful.  Otherwise, use stat(2) on the unique file to check if its link count has increased to 2, in which case the lock
              is also successful.

       O_LARGEFILE
              (LFS) Allow files whose sizes cannot be represented in an off_t (but can be represented in an off64_t) to be  opened.   The  _LARGE‐
              FILE64_SOURCE  macro must be defined (before including any header files) in order to obtain this definition.  Setting the _FILE_OFF‐
              SET_BITS feature test macro to 64 (rather than using O_LARGEFILE) is the preferred method of accessing large files on 32-bit systems
              (see feature_test_macros(7)).

       O_NOATIME (since Linux 2.6.8)
              Do not update the file last access time (st_atime in the inode) when the file is read(2).

              This flag can be employed only if one of the following conditions is true:

              *  The effective UID of the process matches the owner UID of the file.

              *  The  calling process has the CAP_FOWNER capability in its user namespace and the owner UID of the file has a mapping in the name‐
                 space.

              This flag is intended for use by indexing or backup programs, where its use can significantly reduce the amount  of  disk  activity.
              This flag may not be effective on all filesystems.  One example is NFS, where the server maintains the access time.

       O_NOCTTY
              If  pathname  refers  to a terminal device—see tty(4)—it will not become the process's controlling terminal even if the process does
              not have one.

       O_NOFOLLOW
              If the trailing component (i.e., basename) of pathname is a symbolic link, then the open fails,  with  the  error  ELOOP.   Symbolic
              links  in  earlier components of the pathname will still be followed.  (Note that the ELOOP error that can occur in this case is in‐
              distinguishable from the case where an open fails because there are too many symbolic links found while resolving components in  the
              prefix part of the pathname.)

              This  flag  is  a  FreeBSD  extension,  which  was  added  to  Linux  in  version 2.1.126, and has subsequently been standardized in
              POSIX.1-2008.

              See also O_PATH below.

       O_NONBLOCK or O_NDELAY
              When possible, the file is opened in nonblocking mode.  Neither the open() nor any subsequent I/O operations on the file  descriptor
              which is returned will cause the calling process to wait.

              Note  that  the setting of this flag has no effect on the operation of poll(2), select(2), epoll(7), and similar, since those inter‐
              faces merely inform the caller about whether a file descriptor is "ready", meaning that an I/O operation performed on the  file  de‐
              scriptor with the O_NONBLOCK flag clear would not block.

              Note  that this flag has no effect for regular files and block devices; that is, I/O operations will (briefly) block when device ac‐
              tivity is required, regardless of whether O_NONBLOCK is set.  Since O_NONBLOCK semantics might eventually be  implemented,  applica‐
              tions should not depend upon blocking behavior when specifying this flag for regular files and block devices.

              For  the handling of FIFOs (named pipes), see also fifo(7).  For a discussion of the effect of O_NONBLOCK in conjunction with manda‐
              tory file locks and with file leases, see fcntl(2).

       O_PATH (since Linux 2.6.39)
              Obtain a file descriptor that can be used for two purposes: to indicate a location in the filesystem tree and to perform  operations
              that  act  purely  at the file descriptor level.  The file itself is not opened, and other file operations (e.g., read(2), write(2),
              fchmod(2), fchown(2), fgetxattr(2), ioctl(2), mmap(2)) fail with the error EBADF.

              The following operations can be performed on the resulting file descriptor:

              *  close(2).

              *  fchdir(2), if the file descriptor refers to a directory (since Linux 3.5).

              *  fstat(2) (since Linux 3.6).

              *  fstatfs(2) (since Linux 3.12).

              *  Duplicating the file descriptor (dup(2), fcntl(2) F_DUPFD, etc.).

              *  Getting and setting file descriptor flags (fcntl(2) F_GETFD and F_SETFD).

              *  Retrieving open file status flags using the fcntl(2) F_GETFL operation: the returned flags will include the bit O_PATH.

              *  Passing the file descriptor as the dirfd argument of openat() and the other "*at()" system calls.  This includes  linkat(2)  with
                 AT_EMPTY_PATH (or via procfs using AT_SYMLINK_FOLLOW) even if the file is not a directory.

              *  Passing the file descriptor to another process via a UNIX domain socket (see SCM_RIGHTS in unix(7)).

              When O_PATH is specified in flags, flag bits other than O_CLOEXEC, O_DIRECTORY, and O_NOFOLLOW are ignored.

              Opening  a  file or directory with the O_PATH flag requires no permissions on the object itself (but does require execute permission
              on the directories in the path prefix).  Depending on the subsequent operation, a check for suitable file permissions  may  be  per‐
              formed (e.g., fchdir(2) requires execute permission on the directory referred to by its file descriptor argument).  By contrast, ob‐
              taining a reference to a filesystem object by opening it with the O_RDONLY flag requires that the caller have read permission on the
              object, even when the subsequent operation (e.g., fchdir(2), fstat(2)) does not require read permission on the object.

              If  pathname  is a symbolic link and the O_NOFOLLOW flag is also specified, then the call returns a file descriptor referring to the
              symbolic link.  This file descriptor can be used as the dirfd argument in calls to fchownat(2),  fstatat(2),  linkat(2),  and  read‐
              linkat(2) with an empty pathname to have the calls operate on the symbolic link.

              If pathname refers to an automount point that has not yet been triggered, so no other filesystem is mounted on it, then the call re‐
              turns a file descriptor referring to the automount directory without triggering a mount.  fstatfs(2) can then be used  to  determine
              if it is, in fact, an untriggered automount point (.f_type == AUTOFS_SUPER_MAGIC).

              One  use of O_PATH for regular files is to provide the equivalent of POSIX.1's O_EXEC functionality.  This permits us to open a file
              for which we have execute permission but not read permission, and then execute that file, with steps something like the following:

                  char buf[PATH_MAX];
                  fd = open("some_prog", O_PATH);
                  snprintf(buf, PATH_MAX, "/proc/self/fd/%d", fd);
                  execl(buf, "some_prog", (char *) NULL);

              An O_PATH file descriptor can also be passed as the argument of fexecve(3).

       O_SYNC Write operations on the file will complete according to the requirements of synchronized I/O file integrity completion (by  contrast
              with the synchronized I/O data integrity completion provided by O_DSYNC.)

              By  the  time  write(2)  (or  similar) returns, the output data and associated file metadata have been transferred to the underlying
              hardware (i.e., as though each write(2) was followed by a call to fsync(2)).  See NOTES below.

       O_TMPFILE (since Linux 3.11)
              Create an unnamed temporary regular file.  The pathname argument specifies a directory; an unnamed inode will be created in that di‐
              rectory's  filesystem.  Anything written to the resulting file will be lost when the last file descriptor is closed, unless the file
              is given a name.

              O_TMPFILE must be specified with one of O_RDWR or O_WRONLY and, optionally, O_EXCL.  If O_EXCL is not specified, then linkat(2)  can
              be used to link the temporary file into the filesystem, making it permanent, using code like the following:

                  char path[PATH_MAX];
                  fd = open("/path/to/dir", O_TMPFILE | O_RDWR,
                                          S_IRUSR | S_IWUSR);

                  /* File I/O on 'fd'... */

                  linkat(fd, NULL, AT_FDCWD, "/path/for/file", AT_EMPTY_PATH);

                  /* If the caller doesn't have the CAP_DAC_READ_SEARCH
                     capability (needed to use AT_EMPTY_PATH with linkat(2)),
                     and there is a proc(5) filesystem mounted, then the
                     linkat(2) call above can be replaced with:

                  snprintf(path, PATH_MAX,  "/proc/self/fd/%d", fd);
                  linkat(AT_FDCWD, path, AT_FDCWD, "/path/for/file",
                                          AT_SYMLINK_FOLLOW);
                  */

              In this case, the open() mode argument determines the file permission mode, as with O_CREAT.

              Specifying O_EXCL in conjunction with O_TMPFILE prevents a temporary file from being linked into the filesystem in the above manner.
              (Note that the meaning of O_EXCL in this case is different from the meaning of O_EXCL otherwise.)

              There are two main use cases for O_TMPFILE:

              *  Improved tmpfile(3) functionality: race-free creation of temporary files that (1) are automatically deleted when closed; (2)  can
                 never  be  reached  via  any pathname; (3) are not subject to symlink attacks; and (4) do not require the caller to devise unique
                 names.

              *  Creating a file that is initially invisible, which is then populated with data and adjusted to have  appropriate  filesystem  at‐
                 tributes  (fchown(2),  fchmod(2), fsetxattr(2), etc.)  before being atomically linked into the filesystem in a fully formed state
                 (using linkat(2) as described above).

              O_TMPFILE requires support by the underlying filesystem; only a subset of Linux filesystems provide that support.   In  the  initial
              implementation,  support was provided in the ext2, ext3, ext4, UDF, Minix, and shmem filesystems.  Support for other filesystems has
              subsequently been added as follows: XFS (Linux 3.15); Btrfs (Linux 3.16); F2FS (Linux 3.16); and ubifs (Linux 4.9)

       O_TRUNC
              If the file already exists and is a regular file and the access mode allows writing (i.e., is O_RDWR or O_WRONLY) it will  be  trun‐
              cated to length 0.  If the file is a FIFO or terminal device file, the O_TRUNC flag is ignored.  Otherwise, the effect of O_TRUNC is
              unspecified.

   creat()
       A call to creat() is equivalent to calling open() with flags equal to O_CREAT|O_WRONLY|O_TRUNC.

   openat()
       The openat() system call operates in exactly the same way as open(), except for the differences described here.

       If the pathname given in pathname is relative, then it is interpreted relative to the directory referred to by the  file  descriptor  dirfd
       (rather than relative to the current working directory of the calling process, as is done by open() for a relative pathname).

       If  pathname is relative and dirfd is the special value AT_FDCWD, then pathname is interpreted relative to the current working directory of
       the calling process (like open()).

       If pathname is absolute, then dirfd is ignored.

   openat2(2)
       The openat2(2) system call is an extension of openat(), and provides a superset of the features of openat().  It is documented  separately,
       in openat2(2).

RETURN VALUE
       open(),  openat(),  and creat() return the new file descriptor (a nonnegative integer), or -1 if an error occurred (in which case, errno is
       set appropriately).

ERRORS
       open(), openat(), and creat() can fail with the following errors:

       EACCES The requested access to the file is not allowed, or search permission is denied for one of the directories in  the  path  prefix  of
              pathname, or the file did not exist yet and write access to the parent directory is not allowed.  (See also path_resolution(7).)

       EACCES Where  O_CREAT  is  specified,  the protected_fifos or protected_regular sysctl is enabled, the file already exists and is a FIFO or
              regular file, the owner of the file is neither the current user nor the owner of the containing directory, and the containing direc‐
              tory  is  both  world-  or  group-writable  and  sticky.   For  details,  see  the  descriptions of /proc/sys/fs/protected_fifos and
              /proc/sys/fs/protected_regular in proc(5).

       EBUSY  O_EXCL was specified in flags and pathname refers to a block device that is in use by the system (e.g., it is mounted).

       EDQUOT Where O_CREAT is specified, the file does not exist, and the user's quota of disk blocks or inodes on the filesystem  has  been  ex‐
              hausted.

       EEXIST pathname already exists and O_CREAT and O_EXCL were used.

       EFAULT pathname points outside your accessible address space.

       EFBIG  See EOVERFLOW.

       EINTR  While  blocked  waiting  to complete an open of a slow device (e.g., a FIFO; see fifo(7)), the call was interrupted by a signal han‐
              dler; see signal(7).

       EINVAL The filesystem does not support the O_DIRECT flag.  See NOTES for more information.

       EINVAL Invalid value in flags.

       EINVAL O_TMPFILE was specified in flags, but neither O_WRONLY nor O_RDWR was specified.

       EINVAL O_CREAT was specified in flags and the final component ("basename") of the new file's pathname is invalid (e.g., it contains charac‐
              ters not permitted by the underlying filesystem).

       EINVAL The final component ("basename") of pathname is invalid (e.g., it contains characters not permitted by the underlying filesystem).

       EISDIR pathname refers to a directory and the access requested involved writing (that is, O_WRONLY or O_RDWR is set).

       EISDIR pathname  refers  to an existing directory, O_TMPFILE and one of O_WRONLY or O_RDWR were specified in flags, but this kernel version
              does not provide the O_TMPFILE functionality.

       ELOOP  Too many symbolic links were encountered in resolving pathname.

       ELOOP  pathname was a symbolic link, and flags specified O_NOFOLLOW but not O_PATH.

       EMFILE The per-process limit on the number of open file descriptors has been  reached  (see  the  description  of  RLIMIT_NOFILE  in  getr‐
              limit(2)).

       ENAMETOOLONG
              pathname was too long.

       ENFILE The system-wide limit on the total number of open files has been reached.

       ENODEV pathname  refers  to a device special file and no corresponding device exists.  (This is a Linux kernel bug; in this situation ENXIO
              must be returned.)

       ENOENT O_CREAT is not set and the named file does not exist.

       ENOENT A directory component in pathname does not exist or is a dangling symbolic link.

       ENOENT pathname refers to a nonexistent directory, O_TMPFILE and one of O_WRONLY or O_RDWR were specified in flags, but this kernel version
              does not provide the O_TMPFILE functionality.

       ENOMEM The named file is a FIFO, but memory for the FIFO buffer can't be allocated because the per-user hard limit on memory allocation for
              pipes has been reached and the caller is not privileged; see pipe(7).

       ENOMEM Insufficient kernel memory was available.

       ENOSPC pathname was to be created but the device containing pathname has no room for the new file.

       ENOTDIR
              A component used as a directory in pathname is not, in fact, a directory, or O_DIRECTORY was specified and pathname was not a direc‐
              tory.

       ENXIO  O_NONBLOCK | O_WRONLY is set, the named file is a FIFO, and no process has the FIFO open for reading.

       ENXIO  The file is a device special file and no corresponding device exists.

       ENXIO  The file is a UNIX domain socket.

       EOPNOTSUPP
              The filesystem containing pathname does not support O_TMPFILE.

       EOVERFLOW
              pathname  refers  to  a  regular  file that is too large to be opened.  The usual scenario here is that an application compiled on a
              32-bit platform without -D_FILE_OFFSET_BITS=64 tried to open a file whose size exceeds (1<<31)-1 bytes; see also O_LARGEFILE  above.
              This is the error specified by POSIX.1; in kernels before 2.6.24, Linux gave the error EFBIG for this case.

       EPERM  The O_NOATIME flag was specified, but the effective user ID of the caller did not match the owner of the file and the caller was not
              privileged.

       EPERM  The operation was prevented by a file seal; see fcntl(2).

       EROFS  pathname refers to a file on a read-only filesystem and write access was requested.

       ETXTBSY
              pathname refers to an executable image which is currently being executed and write access was requested.

       ETXTBSY
              pathname refers to a file that is currently in use as a swap file, and the O_TRUNC flag was specified.

       ETXTBSY
              pathname refers to a file that is currently being read by the kernel (e.g., for module/firmware loading), and write access  was  re‐
              quested.

       EWOULDBLOCK
              The O_NONBLOCK flag was specified, and an incompatible lease was held on the file (see fcntl(2)).

       The following additional errors can occur for openat():

       EBADF  dirfd is not a valid file descriptor.

       ENOTDIR
              pathname is a relative pathname and dirfd is a file descriptor referring to a file other than a directory.

VERSIONS
       openat() was added to Linux in kernel 2.6.16; library support was added to glibc in version 2.4.

CONFORMING TO
       open(), creat() SVr4, 4.3BSD, POSIX.1-2001, POSIX.1-2008.

       openat(): POSIX.1-2008.

       openat2(2) is Linux-specific.

       The O_DIRECT, O_NOATIME, O_PATH, and O_TMPFILE flags are Linux-specific.  One must define _GNU_SOURCE to obtain their definitions.

       The  O_CLOEXEC,  O_DIRECTORY, and O_NOFOLLOW flags are not specified in POSIX.1-2001, but are specified in POSIX.1-2008.  Since glibc 2.12,
       one can obtain their definitions by defining either _POSIX_C_SOURCE with a value greater than or equal to 200809L or _XOPEN_SOURCE  with  a
       value greater than or equal to 700.  In glibc 2.11 and earlier, one obtains the definitions by defining _GNU_SOURCE.

       As  noted in feature_test_macros(7), feature test macros such as _POSIX_C_SOURCE, _XOPEN_SOURCE, and _GNU_SOURCE must be defined before in‐
       cluding any header files.

NOTES
       Under Linux, the O_NONBLOCK flag is sometimes used in cases where one wants to open but does not necessarily have the intention to read  or
       write.  For example, this may be used to open a device in order to get a file descriptor for use with ioctl(2).

       The (undefined) effect of O_RDONLY | O_TRUNC varies among implementations.  On many systems the file is actually truncated.

       Note that open() can open device special files, but creat() cannot create them; use mknod(2) instead.

       If  the  file is newly created, its st_atime, st_ctime, st_mtime fields (respectively, time of last access, time of last status change, and
       time of last modification; see stat(2)) are set to the current time, and so are the st_ctime and st_mtime fields of the  parent  directory.
       Otherwise, if the file is modified because of the O_TRUNC flag, its st_ctime and st_mtime fields are set to the current time.

       The files in the /proc/[pid]/fd directory show the open file descriptors of the process with the PID pid.  The files in the /proc/[pid]/fd‐
       info directory show even more information about these file descriptors.  See proc(5) for further details of both of these directories.

       The Linux header file <asm/fcntl.h> doesn't define O_ASYNC; the (BSD-derived) FASYNC synonym is defined instead.

   Open file descriptions
       The term open file description is the one used by POSIX to refer to the entries in the system-wide table of open files.  In other contexts,
       this  object is variously also called an "open file object", a "file handle", an "open file table entry", or—in kernel-developer parlance—a
       struct file.

       When a file descriptor is duplicated (using dup(2) or similar), the duplicate refers to the same open file description as the original file
       descriptor,  and  the  two  file descriptors consequently share the file offset and file status flags.  Such sharing can also occur between
       processes: a child process created via fork(2) inherits duplicates of its parent's file descriptors, and those duplicates refer to the same
       open file descriptions.

       Each  open()  of a file creates a new open file description; thus, there may be multiple open file descriptions corresponding to a file in‐
       ode.

       On Linux, one can use the kcmp(2) KCMP_FILE operation to test whether two file descriptors (in the same process or in  two  different  pro‐
       cesses) refer to the same open file description.

   Synchronized I/O
       The  POSIX.1-2008  "synchronized  I/O"  option  specifies  different  variants  of synchronized I/O, and specifies the open() flags O_SYNC,
       O_DSYNC, and O_RSYNC for controlling the behavior.  Regardless of whether an implementation supports this option, it must at least  support
       the use of O_SYNC for regular files.

       Linux  implements  O_SYNC  and  O_DSYNC,  but  not  O_RSYNC.  Somewhat incorrectly, glibc defines O_RSYNC to have the same value as O_SYNC.
       (O_RSYNC is defined in the Linux header file <asm/fcntl.h> on HP PA-RISC, but it is not used.)

       O_SYNC provides synchronized I/O file integrity completion, meaning write operations will flush data and all associated metadata to the un‐
       derlying hardware.  O_DSYNC provides synchronized I/O data integrity completion, meaning write operations will flush data to the underlying
       hardware, but will only flush metadata updates that are required to allow a subsequent read operation to complete successfully.   Data  in‐
       tegrity  completion  can reduce the number of disk operations that are required for applications that don't need the guarantees of file in‐
       tegrity completion.

       To understand the difference between the two types of completion, consider two pieces of file metadata: the file  last  modification  time‐
       stamp (st_mtime) and the file length.  All write operations will update the last file modification timestamp, but only writes that add data
       to the end of the file will change the file length.  The last modification timestamp is not needed to ensure that a read completes success‐
       fully,  but the file length is.  Thus, O_DSYNC would only guarantee to flush updates to the file length metadata (whereas O_SYNC would also
       always flush the last modification timestamp metadata).

       Before Linux 2.6.33, Linux implemented only the O_SYNC flag for open().  However, when that flag was specified, most  filesystems  actually
       provided the equivalent of synchronized I/O data integrity completion (i.e., O_SYNC was actually implemented as the equivalent of O_DSYNC).

       Since Linux 2.6.33, proper O_SYNC support is provided.  However, to ensure backward binary compatibility, O_DSYNC was defined with the same
       value as the historical O_SYNC, and O_SYNC was defined as a new (two-bit) flag value that includes the O_DSYNC flag  value.   This  ensures
       that applications compiled against new headers get at least O_DSYNC semantics on pre-2.6.33 kernels.

   C library/kernel differences
       Since  version  2.26,  the glibc wrapper function for open() employs the openat() system call, rather than the kernel's open() system call.
       For certain architectures, this is also true in glibc versions before 2.26.

   NFS
       There are many infelicities in the protocol underlying NFS, affecting amongst others O_SYNC and O_NDELAY.

       On NFS filesystems with UID mapping enabled, open() may return a file descriptor but, for example, read(2) requests are denied with EACCES.
       This  is because the client performs open() by checking the permissions, but UID mapping is performed by the server upon read and write re‐
       quests.

   FIFOs
       Opening the read or write end of a FIFO blocks until the other end is also opened (by another process or thread).  See fifo(7) for  further
       details.

   File access mode
       Unlike  the  other  values  that can be specified in flags, the access mode values O_RDONLY, O_WRONLY, and O_RDWR do not specify individual
       bits.  Rather, they define the low order two bits of flags, and are defined respectively as 0, 1, and 2.  In other words,  the  combination
       O_RDONLY | O_WRONLY is a logical error, and certainly does not have the same meaning as O_RDWR.

       Linux reserves the special, nonstandard access mode 3 (binary 11) in flags to mean: check for read and write permission on the file and re‐
       turn a file descriptor that can't be used for reading or writing.  This nonstandard access mode is used by some Linux drivers to  return  a
       file descriptor that is to be used only for device-specific ioctl(2) operations.

   Rationale for openat() and other directory file descriptor APIs
       openat()  and the other system calls and library functions that take a directory file descriptor argument (i.e., execveat(2), faccessat(2),
       fanotify_mark(2),  fchmodat(2),  fchownat(2),  fspick(2),  fstatat(2),  futimesat(2),  linkat(2),  mkdirat(2),  move_mount(2),  mknodat(2),
       name_to_handle_at(2), open_tree(2), openat2(2), readlinkat(2), renameat(2), statx(2), symlinkat(2), unlinkat(2), utimensat(2), mkfifoat(3),
       and scandirat(3)) address two problems with the older interfaces that preceded them.  Here, the explanation is in  terms  of  the  openat()
       call, but the rationale is analogous for the other interfaces.

       First,  openat()  allows an application to avoid race conditions that could occur when using open() to open files in directories other than
       the current working directory.  These race conditions result from the fact that some component of the  directory  prefix  given  to  open()
       could  be changed in parallel with the call to open().  Suppose, for example, that we wish to create the file dir1/dir2/xxx.dep if the file
       dir1/dir2/xxx exists.  The problem is that between the existence check and the file-creation step, dir1 or dir2 (which  might  be  symbolic
       links)  could  be  modified to point to a different location.  Such races can be avoided by opening a file descriptor for the target direc‐
       tory, and then specifying that file descriptor as the dirfd argument of (say) fstatat(2) and openat().  The use of the dirfd file  descrip‐
       tor also has other benefits:

       *  the file descriptor is a stable reference to the directory, even if the directory is renamed; and

       *  the  open  file descriptor prevents the underlying filesystem from being dismounted, just as when a process has a current working direc‐
          tory on a filesystem.

       Second, openat() allows the implementation of a per-thread "current working directory", via file descriptor(s) maintained by  the  applica‐
       tion.  (This functionality can also be obtained by tricks based on the use of /proc/self/fd/dirfd, but less efficiently.)

       The  dirfd  argument for these APIs can be obtained by using open() or openat() to open a directory (with either the O_RDONLY or the O_PATH
       flag).  Alternatively, such a file descriptor can be obtained by applying dirfd(3) to a directory stream created using opendir(3).

       When these APIs are given a dirfd argument of AT_FDCWD or the specified pathname is absolute, then they handle their pathname  argument  in
       the same way as the corresponding conventional APIs.  However, in this case, several of the APIs have a flags argument that provides access
       to functionality that is not available with the corresponding conventional APIs.

   O_DIRECT
       The O_DIRECT flag may impose alignment restrictions on the length and address of user-space buffers and the file offset of I/Os.  In  Linux
       alignment  restrictions vary by filesystem and kernel version and might be absent entirely.  However there is currently no filesystem-inde‐
       pendent interface for an application to discover these restrictions for a given file or filesystem.  Some filesystems provide their own in‐
       terfaces for doing so, for example the XFS_IOC_DIOINFO operation in xfsctl(3).

       Under  Linux  2.4, transfer sizes, and the alignment of the user buffer and the file offset must all be multiples of the logical block size
       of the filesystem.  Since Linux 2.6.0, alignment to the logical block size of the underlying storage (typically 512 bytes)  suffices.   The
       logical block size can be determined using the ioctl(2) BLKSSZGET operation or from the shell using the command:

           blockdev --getss

       O_DIRECT  I/Os  should never be run concurrently with the fork(2) system call, if the memory buffer is a private mapping (i.e., any mapping
       created with the mmap(2) MAP_PRIVATE flag; this includes memory allocated on the heap and statically allocated buffers).   Any  such  I/Os,
       whether  submitted  via  an asynchronous I/O interface or from another thread in the process, should be completed before fork(2) is called.
       Failure to do so can result in data corruption and undefined behavior in parent and child processes.  This restriction does not apply  when
       the  memory  buffer  for the O_DIRECT I/Os was created using shmat(2) or mmap(2) with the MAP_SHARED flag.  Nor does this restriction apply
       when the memory buffer has been advised as MADV_DONTFORK with madvise(2), ensuring that it  will  not  be  available  to  the  child  after
       fork(2).

       The  O_DIRECT flag was introduced in SGI IRIX, where it has alignment restrictions similar to those of Linux 2.4.  IRIX has also a fcntl(2)
       call to query appropriate alignments, and sizes.  FreeBSD 4.x introduced a flag of the same name, but without alignment restrictions.

       O_DIRECT support was added under Linux in kernel version 2.4.10.  Older Linux kernels simply ignore this flag.  Some  filesystems  may  not
       implement the flag, in which case open() fails with the error EINVAL if it is used.

       Applications  should  avoid  mixing  O_DIRECT and normal I/O to the same file, and especially to overlapping byte regions in the same file.
       Even when the filesystem correctly handles the coherency issues in this situation, overall I/O throughput is likely to be slower than using
       either mode alone.  Likewise, applications should avoid mixing mmap(2) of files with direct I/O to the same files.

       The  behavior  of O_DIRECT with NFS will differ from local filesystems.  Older kernels, or kernels configured in certain ways, may not sup‐
       port this combination.  The NFS protocol does not support passing the flag to the server, so O_DIRECT I/O will bypass the page  cache  only
       on  the client; the server may still cache the I/O.  The client asks the server to make the I/O synchronous to preserve the synchronous se‐
       mantics of O_DIRECT.  Some servers will perform poorly under these circumstances, especially if the I/O size is small.   Some  servers  may
       also  be  configured to lie to clients about the I/O having reached stable storage; this will avoid the performance penalty at some risk to
       data integrity in the event of server power failure.  The Linux NFS client places no alignment restrictions on O_DIRECT I/O.

       In summary, O_DIRECT is a potentially powerful tool that should be used with caution.  It is recommended that  applications  treat  use  of
       O_DIRECT as a performance option which is disabled by default.

BUGS
       Currently, it is not possible to enable signal-driven I/O by specifying O_ASYNC when calling open(); use fcntl(2) to enable this flag.

       One must check for two different error codes, EISDIR and ENOENT, when trying to determine whether the kernel supports O_TMPFILE functional‐
       ity.

       When both O_CREAT and O_DIRECTORY are specified in flags and the file specified by pathname does not exist, open() will  create  a  regular
       file (i.e., O_DIRECTORY is ignored).

SEE ALSO
       chmod(2),  chown(2), close(2), dup(2), fcntl(2), link(2), lseek(2), mknod(2), mmap(2), mount(2), open_by_handle_at(2), openat2(2), read(2),
       socket(2), stat(2), umask(2), unlink(2), write(2), fopen(3), acl(5), fifo(7), inode(7), path_resolution(7), symlink(7)

COLOPHON
       This page is part of release 5.10 of the Linux man-pages project.  A description of the project, information about reporting bugs, and  the
       latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                               2020-11-01                                                             OPEN(2)

## pread64

PREAD(2)                                                     Linux Programmer's Manual                                                    PREAD(2)

NAME
       pread, pwrite - read from or write to a file descriptor at a given offset

SYNOPSIS
       #include <unistd.h>

       ssize_t pread(int fd, void *buf, size_t count, off_t offset);

       ssize_t pwrite(int fd, const void *buf, size_t count, off_t offset);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       pread(), pwrite():
           _XOPEN_SOURCE >= 500
           || /* Since glibc 2.12: */ _POSIX_C_SOURCE >= 200809L

DESCRIPTION
       pread() reads up to count bytes from file descriptor fd at offset offset (from the start of the file) into the buffer starting at buf.  The
       file offset is not changed.

       pwrite() writes up to count bytes from the buffer starting at buf to the file descriptor fd at offset  offset.   The  file  offset  is  not
       changed.

       The file referenced by fd must be capable of seeking.

RETURN VALUE
       On  success,  pread()  returns  the  number of bytes read (a return of zero indicates end of file) and pwrite() returns the number of bytes
       written.

       Note that it is not an error for a successful call to transfer fewer bytes than requested (see read(2) and write(2)).

       On error, -1 is returned and errno is set to indicate the cause of the error.

ERRORS
       pread() can fail and set errno to any error specified for read(2) or lseek(2).  pwrite() can fail and set errno to any error specified  for
       write(2) or lseek(2).

VERSIONS
       The  pread()  and  pwrite()  system  calls  were  added to Linux in version 2.1.60; the entries in the i386 system call table were added in
       2.1.69.  C library support (including emulation using lseek(2) on older kernels without the system calls) was added in glibc 2.1.

CONFORMING TO
       POSIX.1-2001, POSIX.1-2008.

NOTES
       The pread() and pwrite() system calls are especially useful in multithreaded applications.  They allow multiple threads to perform  I/O  on
       the same file descriptor without being affected by changes to the file offset by other threads.

   C library/kernel differences
       On  Linux,  the  underlying  system calls were renamed in kernel 2.6: pread() became pread64(), and pwrite() became pwrite64().  The system
       call numbers remained the same.  The glibc pread() and pwrite() wrapper functions transparently deal with the change.

       On some 32-bit architectures, the calling signature for these system calls differ, for the reasons described in syscall(2).

BUGS
       POSIX requires that opening a file with the O_APPEND flag should have no effect on the location at which pwrite() writes data.  However, on
       Linux, if a file is opened with O_APPEND, pwrite() appends data to the end of the file, regardless of the value of offset.

SEE ALSO
       lseek(2), read(2), readv(2), write(2)

COLOPHON
       This  page is part of release 5.10 of the Linux man-pages project.  A description of the project, information about reporting bugs, and the
       latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                               2017-09-15                                                            PREAD(2)

## arch_prctl

ARCH_PRCTL(2)                                                Linux Programmer's Manual                                               ARCH_PRCTL(2)

NAME
       arch_prctl - set architecture-specific thread state

SYNOPSIS
       #include <asm/prctl.h>
       #include <sys/prctl.h>

       int arch_prctl(int code, unsigned long addr);
       int arch_prctl(int code, unsigned long *addr);

DESCRIPTION
       arch_prctl() sets architecture-specific process or thread state.  code selects a subfunction and passes argument addr to it; addr is inter‐
       preted as either an unsigned long for the "set" operations, or as an unsigned long *, for the "get" operations.

       Subfunctions for both x86 and x86-64 are:

       ARCH_SET_CPUID (since Linux 4.12)
              Enable (addr != 0) or disable (addr == 0) the cpuid instruction for the calling thread.  The instruction is enabled by default.   If
              disabled,  any  execution  of a cpuid instruction will instead generate a SIGSEGV signal.  This feature can be used to emulate cpuid
              results that differ from what the underlying hardware would have produced (e.g., in a paravirtualization setting).

              The ARCH_SET_CPUID setting is preserved across fork(2) and clone(2) but reset to the default (i.e., cpuid enabled) on execve(2).

       ARCH_GET_CPUID (since Linux 4.12)
              Return the setting of the flag manipulated by ARCH_SET_CPUID as the result of the system call (1 for enabled, 0 for disabled).  addr
              is ignored.

       Subfunctions for x86-64 only are:

       ARCH_SET_FS
              Set the 64-bit base for the FS register to addr.

       ARCH_GET_FS
              Return the 64-bit base value for the FS register of the calling thread in the unsigned long pointed to by addr.

       ARCH_SET_GS
              Set the 64-bit base for the GS register to addr.

       ARCH_GET_GS
              Return the 64-bit base value for the GS register of the calling thread in the unsigned long pointed to by addr.

RETURN VALUE
       On success, arch_prctl() returns 0; on error, -1 is returned, and errno is set to indicate the error.

ERRORS
       EFAULT addr points to an unmapped address or is outside the process address space.

       EINVAL code is not a valid subcommand.

       EPERM  addr is outside the process address space.

       ENODEV ARCH_SET_CPUID was requested, but the underlying hardware does not support CPUID faulting.

CONFORMING TO
       arch_prctl() is a Linux/x86-64 extension and should not be used in programs intended to be portable.

NOTES
       arch_prctl() is supported only on Linux/x86-64 for 64-bit programs currently.

       The 64-bit base changes when a new 32-bit segment selector is loaded.

       ARCH_SET_GS is disabled in some kernels.

       Context switches for 64-bit segment bases are rather expensive.  As an optimization, if a 32-bit TLS base address is used, arch_prctl() may
       use a real TLS entry as if set_thread_area(2) had been called, instead of manipulating the segment base register directly.  Memory  in  the
       first 2 GB of address space can be allocated by using mmap(2) with the MAP_32BIT flag.

       Because  of  the  aforementioned optimization, using arch_prctl() and set_thread_area(2) in the same thread is dangerous, as they may over‐
       write each other's TLS entries.

       As of version 2.7, glibc provides no prototype for arch_prctl().  You have to declare it yourself for now.  This may  be  fixed  in  future
       glibc versions.

       FS may be already used by the threading library.  Programs that use ARCH_SET_FS directly are very likely to crash.

SEE ALSO
       mmap(2), modify_ldt(2), prctl(2), set_thread_area(2)

       AMD X86-64 Programmer's manual

COLOPHON
       This  page is part of release 5.10 of the Linux man-pages project.  A description of the project, information about reporting bugs, and the
       latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                               2020-04-11                                                       ARCH_PRCTL(2)

## statfs

STATFS(2)                                                    Linux Programmer's Manual                                                   STATFS(2)

NAME
       statfs, fstatfs - get filesystem statistics

SYNOPSIS
       #include <sys/vfs.h>    /* or <sys/statfs.h> */

       int statfs(const char *path, struct statfs *buf);
       int fstatfs(int fd, struct statfs *buf);

DESCRIPTION
       The  statfs()  system call returns information about a mounted filesystem.  path is the pathname of any file within the mounted filesystem.
       buf is a pointer to a statfs structure defined approximately as follows:

           struct statfs {
               __fsword_t f_type;    /* Type of filesystem (see below) */
               __fsword_t f_bsize;   /* Optimal transfer block size */
               fsblkcnt_t f_blocks;  /* Total data blocks in filesystem */
               fsblkcnt_t f_bfree;   /* Free blocks in filesystem */
               fsblkcnt_t f_bavail;  /* Free blocks available to
                                        unprivileged user */
               fsfilcnt_t f_files;   /* Total inodes in filesystem */
               fsfilcnt_t f_ffree;   /* Free inodes in filesystem */
               fsid_t     f_fsid;    /* Filesystem ID */
               __fsword_t f_namelen; /* Maximum length of filenames */
               __fsword_t f_frsize;  /* Fragment size (since Linux 2.6) */
               __fsword_t f_flags;   /* Mount flags of filesystem
                                        (since Linux 2.6.36) */
               __fsword_t f_spare[xxx];
                               /* Padding bytes reserved for future use */
           };

       The following filesystem types may appear in f_type:

           ADFS_SUPER_MAGIC      0xadf5
           AFFS_SUPER_MAGIC      0xadff
           AFS_SUPER_MAGIC       0x5346414f
           ANON_INODE_FS_MAGIC   0x09041934 /* Anonymous inode FS (for
                                               pseudofiles that have no name;
                                               e.g., epoll, signalfd, bpf) */
           AUTOFS_SUPER_MAGIC    0x0187
           BDEVFS_MAGIC          0x62646576
           BEFS_SUPER_MAGIC      0x42465331
           BFS_MAGIC             0x1badface
           BINFMTFS_MAGIC        0x42494e4d
           BPF_FS_MAGIC          0xcafe4a11
           BTRFS_SUPER_MAGIC     0x9123683e
           BTRFS_TEST_MAGIC      0x73727279
           CGROUP_SUPER_MAGIC    0x27e0eb   /* Cgroup pseudo FS */
           CGROUP2_SUPER_MAGIC   0x63677270 /* Cgroup v2 pseudo FS */
           CIFS_MAGIC_NUMBER     0xff534d42
           CODA_SUPER_MAGIC      0x73757245
           COH_SUPER_MAGIC       0x012ff7b7
           CRAMFS_MAGIC          0x28cd3d45
           DEBUGFS_MAGIC         0x64626720
           DEVFS_SUPER_MAGIC     0x1373     /* Linux 2.6.17 and earlier */
           DEVPTS_SUPER_MAGIC    0x1cd1
           ECRYPTFS_SUPER_MAGIC  0xf15f
           EFIVARFS_MAGIC        0xde5e81e4
           EFS_SUPER_MAGIC       0x00414a53
           EXT_SUPER_MAGIC       0x137d     /* Linux 2.0 and earlier */
           EXT2_OLD_SUPER_MAGIC  0xef51
           EXT2_SUPER_MAGIC      0xef53
           EXT3_SUPER_MAGIC      0xef53
           EXT4_SUPER_MAGIC      0xef53
           F2FS_SUPER_MAGIC      0xf2f52010
           FUSE_SUPER_MAGIC      0x65735546
           FUTEXFS_SUPER_MAGIC   0xbad1dea  /* Unused */
           HFS_SUPER_MAGIC       0x4244
           HOSTFS_SUPER_MAGIC    0x00c0ffee
           HPFS_SUPER_MAGIC      0xf995e849
           HUGETLBFS_MAGIC       0x958458f6
           ISOFS_SUPER_MAGIC     0x9660
           JFFS2_SUPER_MAGIC     0x72b6
           JFS_SUPER_MAGIC       0x3153464a
           MINIX_SUPER_MAGIC     0x137f     /* original minix FS */
           MINIX_SUPER_MAGIC2    0x138f     /* 30 char minix FS */
           MINIX2_SUPER_MAGIC    0x2468     /* minix V2 FS */
           MINIX2_SUPER_MAGIC2   0x2478     /* minix V2 FS, 30 char names */
           MINIX3_SUPER_MAGIC    0x4d5a     /* minix V3 FS, 60 char names */
           MQUEUE_MAGIC          0x19800202 /* POSIX message queue FS */
           MSDOS_SUPER_MAGIC     0x4d44
           MTD_INODE_FS_MAGIC    0x11307854
           NCP_SUPER_MAGIC       0x564c
           NFS_SUPER_MAGIC       0x6969
           NILFS_SUPER_MAGIC     0x3434
           NSFS_MAGIC            0x6e736673
           NTFS_SB_MAGIC         0x5346544e
           OCFS2_SUPER_MAGIC     0x7461636f
           OPENPROM_SUPER_MAGIC  0x9fa1
           OVERLAYFS_SUPER_MAGIC 0x794c7630
           PIPEFS_MAGIC          0x50495045
           PROC_SUPER_MAGIC      0x9fa0     /* /proc FS */
           PSTOREFS_MAGIC        0x6165676c
           QNX4_SUPER_MAGIC      0x002f
           QNX6_SUPER_MAGIC      0x68191122
           RAMFS_MAGIC           0x858458f6
           REISERFS_SUPER_MAGIC  0x52654973
           ROMFS_MAGIC           0x7275
           SECURITYFS_MAGIC      0x73636673
           SELINUX_MAGIC         0xf97cff8c
           SMACK_MAGIC           0x43415d53
           SMB_SUPER_MAGIC       0x517b
           SMB2_MAGIC_NUMBER     0xfe534d42
           SOCKFS_MAGIC          0x534f434b
           SQUASHFS_MAGIC        0x73717368
           SYSFS_MAGIC           0x62656572
           SYSV2_SUPER_MAGIC     0x012ff7b6
           SYSV4_SUPER_MAGIC     0x012ff7b5
           TMPFS_MAGIC           0x01021994
           TRACEFS_MAGIC         0x74726163
           UDF_SUPER_MAGIC       0x15013346
           UFS_MAGIC             0x00011954
           USBDEVICE_SUPER_MAGIC 0x9fa2
           V9FS_MAGIC            0x01021997
           VXFS_SUPER_MAGIC      0xa501fcf5
           XENFS_SUPER_MAGIC     0xabba1974
           XENIX_SUPER_MAGIC     0x012ff7b4
           XFS_SUPER_MAGIC       0x58465342
           _XIAFS_SUPER_MAGIC    0x012fd16d /* Linux 2.0 and earlier */

       Most of these MAGIC constants are defined in /usr/include/linux/magic.h, and some are hardcoded in kernel sources.

       The f_flags field is a bit mask indicating mount options for the filesystem.  It contains zero or more of the following bits:

       ST_MANDLOCK
              Mandatory locking is permitted on the filesystem (see fcntl(2)).

       ST_NOATIME
              Do not update access times; see mount(2).

       ST_NODEV
              Disallow access to device special files on this filesystem.

       ST_NODIRATIME
              Do not update directory access times; see mount(2).

       ST_NOEXEC
              Execution of programs is disallowed on this filesystem.

       ST_NOSUID
              The set-user-ID and set-group-ID bits are ignored by exec(3) for executable files on this filesystem

       ST_RDONLY
              This filesystem is mounted read-only.

       ST_RELATIME
              Update atime relative to mtime/ctime; see mount(2).

       ST_SYNCHRONOUS
              Writes are synched to the filesystem immediately (see the description of O_SYNC in open(2)).

       ST_NOSYMFOLLOW (since Linux 5.10)
              Symbolic links are not followed when resolving paths; see mount(2).

       Nobody knows what f_fsid is supposed to contain (but see below).

       Fields that are undefined for a particular filesystem are set to 0.

       fstatfs() returns the same information about an open file referenced by descriptor fd.

RETURN VALUE
       On success, zero is returned.  On error, -1 is returned, and errno is set appropriately.

ERRORS
       EACCES (statfs()) Search permission is denied for a component of the path prefix of path.  (See also path_resolution(7).)

       EBADF  (fstatfs()) fd is not a valid open file descriptor.

       EFAULT buf or path points to an invalid address.

       EINTR  The call was interrupted by a signal; see signal(7).

       EIO    An I/O error occurred while reading from the filesystem.

       ELOOP  (statfs()) Too many symbolic links were encountered in translating path.

       ENAMETOOLONG
              (statfs()) path is too long.

       ENOENT (statfs()) The file referred to by path does not exist.

       ENOMEM Insufficient kernel memory was available.

       ENOSYS The filesystem does not support this call.

       ENOTDIR
              (statfs()) A component of the path prefix of path is not a directory.

       EOVERFLOW
              Some values were too large to be represented in the returned struct.

CONFORMING TO
       Linux-specific.  The Linux statfs() was inspired by the 4.4BSD one (but they do not use the same structure).

NOTES
       The __fsword_t type used for various fields in the statfs structure definition is a glibc internal type, not intended for public use.  This
       leaves  the  programmer  in  a  bit  of a conundrum when trying to copy or compare these fields to local variables in a program.  Using un‐
       signed int for such variables suffices on most systems.

       The original Linux statfs() and fstatfs() system calls were not designed with extremely large file sizes in mind.  Subsequently, Linux  2.6
       added new statfs64() and fstatfs64() system calls that employ a new structure, statfs64.  The new structure contains the same fields as the
       original statfs structure, but the sizes of various fields are increased, to accommodate large file sizes.   The  glibc  statfs()  and  fs‐
       tatfs() wrapper functions transparently deal with the kernel differences.

       Some  systems  have  only <sys/vfs.h>, other systems also have <sys/statfs.h>, where the former includes the latter.  So it seems including
       the former is the best choice.

       LSB has deprecated the library calls statfs() and fstatfs() and tells us to use statvfs(2) and fstatvfs(2) instead.

   The f_fsid field
       Solaris, Irix and POSIX have a system call statvfs(2) that returns a struct statvfs (defined in  <sys/statvfs.h>)  containing  an  unsigned
       long  f_fsid.   Linux,  SunOS, HP-UX, 4.4BSD have a system call statfs() that returns a struct statfs (defined in <sys/vfs.h>) containing a
       fsid_t f_fsid, where fsid_t is defined as struct { int val[2]; }.  The same holds for  FreeBSD,  except  that  it  uses  the  include  file
       <sys/mount.h>.

       The general idea is that f_fsid contains some random stuff such that the pair (f_fsid,ino) uniquely determines a file.  Some operating sys‐
       tems use (a variation on) the device number, or the device number combined with the filesystem type.  Several  operating  systems  restrict
       giving out the f_fsid field to the superuser only (and zero it for unprivileged users), because this field is used in the filehandle of the
       filesystem when NFS-exported, and giving it out is a security concern.

       Under some operating systems, the fsid can be used as the second argument to the sysfs(2) system call.

BUGS
       From Linux 2.6.38 up to and including Linux 3.1, fstatfs() failed with the error ENOSYS for file descriptors created by pipe(2).

SEE ALSO
       stat(2), statvfs(3), path_resolution(7)

COLOPHON
       This page is part of release 5.10 of the Linux man-pages project.  A description of the project, information about reporting bugs, and  the
       latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                               2020-12-21                                                           STATFS(2)



## ioctl

IOCTL(2)                                                     Linux Programmer's Manual                                                    IOCTL(2)

NAME
       ioctl - control device

SYNOPSIS
       #include <sys/ioctl.h>

       int ioctl(int fd, unsigned long request, ...);

DESCRIPTION
       The  ioctl()  system  call manipulates the underlying device parameters of special files.  In particular, many operating characteristics of
       character special files (e.g., terminals) may be controlled with ioctl() requests.  The argument fd must be an open file descriptor.

       The second argument is a device-dependent request code.  The third argument is an untyped pointer to memory.  It's traditionally char *argp
       (from the days before void * was valid C), and will be so named for this discussion.

       An  ioctl() request has encoded in it whether the argument is an in parameter or out parameter, and the size of the argument argp in bytes.
       Macros and defines used in specifying an ioctl() request are located in the file <sys/ioctl.h>.  See NOTES.

RETURN VALUE
       Usually, on success zero is returned.  A few ioctl() requests use the return value as an output parameter and return a nonnegative value on
       success.  On error, -1 is returned, and errno is set appropriately.

ERRORS
       EBADF  fd is not a valid file descriptor.

       EFAULT argp references an inaccessible memory area.

       EINVAL request or argp is not valid.

       ENOTTY fd is not associated with a character special device.

       ENOTTY The specified request does not apply to the kind of object that the file descriptor fd references.

CONFORMING TO
       No  single  standard.   Arguments, returns, and semantics of ioctl() vary according to the device driver in question (the call is used as a
       catch-all for operations that don't cleanly fit the UNIX stream I/O model).

       The ioctl() system call appeared in Version 7 AT&T UNIX.

NOTES
       In order to use this call, one needs an open file descriptor.  Often the open(2) call has unwanted side effects, that can be avoided  under
       Linux by giving it the O_NONBLOCK flag.

   ioctl structure
       Ioctl  command  values  are  32-bit  constants.  In principle these constants are completely arbitrary, but people have tried to build some
       structure into them.

       The old Linux situation was that of mostly 16-bit constants, where the last byte is a serial number, and the preceding byte(s) give a  type
       indicating  the  driver.   Sometimes  the major number was used: 0x03 for the HDIO_* ioctls, 0x06 for the LP* ioctls.  And sometimes one or
       more ASCII letters were used.  For example, TCGETS has value 0x00005401, with 0x54 = 'T' indicating the terminal driver,  and  CYGETTIMEOUT
       has value 0x00435906, with 0x43 0x59 = 'C' 'Y' indicating the cyclades driver.

       Later  (0.98p5)  some more information was built into the number.  One has 2 direction bits (00: none, 01: write, 10: read, 11: read/write)
       followed by 14 size bits (giving the size of the argument), followed by an 8-bit type (collecting the ioctls in groups for a common purpose
       or a common driver), and an 8-bit serial number.

       The macros describing this structure live in <asm/ioctl.h> and are _IO(type,nr) and {_IOR,_IOW,_IOWR}(type,nr,size).  They use sizeof(size)
       so that size is a misnomer here: this third argument is a data type.

       Note that the size bits are very unreliable: in lots of cases they are wrong, either because of buggy macros using  sizeof(sizeof(struct)),
       or because of legacy values.

       Thus,  it  seems that the new structure only gave disadvantages: it does not help in checking, but it causes varying values for the various
       architectures.

SEE ALSO
       execve(2), fcntl(2), ioctl_console(2), ioctl_fat(2), ioctl_ficlonerange(2),  ioctl_fideduperange(2),  ioctl_fslabel(2),  ioctl_getfsmap(2),
       ioctl_iflags(2), ioctl_ns(2), ioctl_tty(2), ioctl_userfaultfd(2), open(2), sd(4), tty(4)

COLOPHON
       This  page is part of release 5.10 of the Linux man-pages project.  A description of the project, information about reporting bugs, and the
       latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                               2020-04-11                                                            IOCTL(2)

## getdents64

GETDENTS(2)                                                  Linux Programmer's Manual                                                 GETDENTS(2)

NAME
       getdents, getdents64 - get directory entries

SYNOPSIS
       long getdents(unsigned int fd, struct linux_dirent *dirp,
                    unsigned int count);

       #define _GNU_SOURCE        /* See feature_test_macros(7) */
       #include <dirent.h>

       ssize_t getdents64(int fd, void *dirp, size_t count);

       Note: There is no glibc wrapper for getdents(); see NOTES.

DESCRIPTION
       These  are not the interfaces you are interested in.  Look at readdir(3) for the POSIX-conforming C library interface.  This page documents
       the bare kernel system call interfaces.

   getdents()
       The system call getdents() reads several linux_dirent structures from the directory referred to by the open file  descriptor  fd  into  the
       buffer pointed to by dirp.  The argument count specifies the size of that buffer.

       The linux_dirent structure is declared as follows:

           struct linux_dirent {
               unsigned long  d_ino;     /* Inode number */
               unsigned long  d_off;     /* Offset to next linux_dirent */
               unsigned short d_reclen;  /* Length of this linux_dirent */
               char           d_name[];  /* Filename (null-terminated) */
                                 /* length is actually (d_reclen - 2 -
                                    offsetof(struct linux_dirent, d_name)) */
               /*
               char           pad;       // Zero padding byte
               char           d_type;    // File type (only since Linux
                                         // 2.6.4); offset is (d_reclen - 1)
               */
           }

       d_ino  is  an  inode number.  d_off is the distance from the start of the directory to the start of the next linux_dirent.  d_reclen is the
       size of this entire linux_dirent.  d_name is a null-terminated filename.

       d_type is a byte at the end of the structure that indicates the file type.  It contains one  of  the  following  values  (defined  in  <di‐
       rent.h>):

       DT_BLK      This is a block device.

       DT_CHR      This is a character device.

       DT_DIR      This is a directory.

       DT_FIFO     This is a named pipe (FIFO).

       DT_LNK      This is a symbolic link.

       DT_REG      This is a regular file.

       DT_SOCK     This is a UNIX domain socket.

       DT_UNKNOWN  The file type is unknown.

       The  d_type field is implemented since Linux 2.6.4.  It occupies a space that was previously a zero-filled padding byte in the linux_dirent
       structure.  Thus, on kernels up to and including 2.6.3, attempting to access this field always provides the value 0 (DT_UNKNOWN).

       Currently, only some filesystems (among them: Btrfs, ext2, ext3, and ext4) have full support for returning the file type  in  d_type.   All
       applications must properly handle a return of DT_UNKNOWN.

   getdents64()
       The  original  Linux  getdents()  system  call did not handle large filesystems and large file offsets.  Consequently, Linux 2.4 added get‐
       dents64(), with wider types for the d_ino and d_off fields.  In addition, getdents64() supports an explicit d_type field.

       The getdents64() system call is like getdents(), except that its second argument is a pointer to a buffer containing structures of the fol‐
       lowing type:

           struct linux_dirent64 {
               ino64_t        d_ino;    /* 64-bit inode number */
               off64_t        d_off;    /* 64-bit offset to next structure */
               unsigned short d_reclen; /* Size of this dirent */
               unsigned char  d_type;   /* File type */
               char           d_name[]; /* Filename (null-terminated) */
           };

RETURN VALUE
       On  success,  the number of bytes read is returned.  On end of directory, 0 is returned.  On error, -1 is returned, and errno is set appro‐
       priately.

ERRORS
       EBADF  Invalid file descriptor fd.

       EFAULT Argument points outside the calling process's address space.

       EINVAL Result buffer is too small.

       ENOENT No such directory.

       ENOTDIR
              File descriptor does not refer to a directory.

CONFORMING TO
       SVr4.

NOTES
       Library support for getdents64() was added in glibc 2.30; there is no glibc wrapper for getdents().  Calling getdents() (or getdents64() on
       earlier  glibc versions) requires the use of syscall(2).  In that case you will need to define the linux_dirent or linux_dirent64 structure
       yourself.

       Probably, you want to use readdir(3) instead of these system calls.

       These calls supersede readdir(2).

EXAMPLES
       The program below demonstrates the use of getdents().  The following output shows an example of what we see when running this program on an
       ext2 directory:

           $ ./a.out /testfs/
           --------------- nread=120 ---------------
           inode#    file type  d_reclen  d_off   d_name
                  2  directory    16         12  .
                  2  directory    16         24  ..
                 11  directory    24         44  lost+found
                 12  regular      16         56  a
             228929  directory    16         68  sub
              16353  directory    16         80  sub2
             130817  directory    16       4096  sub3

   Program source

       #define _GNU_SOURCE
       #include <dirent.h>     /* Defines DT_* constants */
       #include <fcntl.h>
       #include <stdint.h>
       #include <stdio.h>
       #include <unistd.h>
       #include <stdlib.h>
       #include <sys/stat.h>
       #include <sys/syscall.h>

       #define handle_error(msg) \
               do { perror(msg); exit(EXIT_FAILURE); } while (0)

       struct linux_dirent {
           unsigned long  d_ino;
           off_t          d_off;
           unsigned short d_reclen;
           char           d_name[];
       };

       #define BUF_SIZE 1024

       int
       main(int argc, char *argv[])
       {
           int fd;
           long nread;
           char buf[BUF_SIZE];
           struct linux_dirent *d;
           char d_type;

           fd = open(argc > 1 ? argv[1] : ".", O_RDONLY | O_DIRECTORY);
           if (fd == -1)
               handle_error("open");

           for (;;) {
               nread = syscall(SYS_getdents, fd, buf, BUF_SIZE);
               if (nread == -1)
                   handle_error("getdents");

               if (nread == 0)
                   break;

               printf("--------------- nread=%d ---------------\n", nread);
               printf("inode#    file type  d_reclen  d_off   d_name\n");
               for (long bpos = 0; bpos < nread;) {
                   d = (struct linux_dirent *) (buf + bpos);
                   printf("%8ld  ", d->d_ino);
                   d_type = *(buf + bpos + d->d_reclen - 1);
                   printf("%-10s ", (d_type == DT_REG) ?  "regular" :
                                    (d_type == DT_DIR) ?  "directory" :
                                    (d_type == DT_FIFO) ? "FIFO" :
                                    (d_type == DT_SOCK) ? "socket" :
                                    (d_type == DT_LNK) ?  "symlink" :
                                    (d_type == DT_BLK) ?  "block dev" :
                                    (d_type == DT_CHR) ?  "char dev" : "???");
                   printf("%4d %10jd  %s\n", d->d_reclen,
                           (intmax_t) d->d_off, d->d_name);
                   bpos += d->d_reclen;
               }
           }

           exit(EXIT_SUCCESS);
       }

SEE ALSO
       readdir(2), readdir(3), inode(7)

COLOPHON
       This  page is part of release 5.10 of the Linux man-pages project.  A description of the project, information about reporting bugs, and the
       latest version of this page, can be found at https://www.kernel.org/doc/man-pages/.

Linux                                                               2020-11-01                                                         GETDENTS(2)
